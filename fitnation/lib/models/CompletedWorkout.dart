import 'dart:convert'; // Added for JSON encoding/decoding
import 'package:uuid/uuid.dart';
import 'package:json_annotation/json_annotation.dart';

part 'CompletedWorkout.g.dart'; // This will be generated by build_runner

@JsonSerializable(explicitToJson: true) // explicitToJson for nested objects
class CompletedWorkoutSet {
  @JsonKey(includeToJson: false, includeFromJson: false)
  final String id;
  // weight and reps are already correct for the backend schema (string)
  final String weight;
  final String reps;
  @JsonKey(includeToJson: false, includeFromJson: false)
  final DateTime createdAt;

  CompletedWorkoutSet({
    String? id,
    required this.weight,
    required this.reps,
    DateTime? createdAt,
  }) : id = id ?? const Uuid().v4(),
       createdAt = createdAt ?? DateTime.now();

  factory CompletedWorkoutSet.fromJson(Map<String, dynamic> json) =>
      _$CompletedWorkoutSetFromJson(json);
  Map<String, dynamic> toJson() => _$CompletedWorkoutSetToJson(this);

  // For SQLite
  factory CompletedWorkoutSet.fromMap(Map<String, dynamic> map) {
    return CompletedWorkoutSet(
      id: map['id'] as String,
      weight: map['weight'] as String,
      reps: map['reps'] as String,
      createdAt: DateTime.parse(
        map['created_at'] as String,
      ), // Corrected from createdAt
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'weight': weight,
      'reps': reps,
      'created_at': createdAt.toIso8601String(), // Corrected to created_at
    };
  }

  CompletedWorkoutSet copyWith({
    String? id,
    String? weight,
    String? reps,
    DateTime? createdAt,
  }) {
    return CompletedWorkoutSet(
      id: id ?? this.id,
      weight: weight ?? this.weight,
      reps: reps ?? this.reps,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}

@JsonSerializable(explicitToJson: true) // Ensure nested toJson is called
class CompletedWorkoutExercise {
  @JsonKey(
    includeToJson: false,
    includeFromJson: false,
  ) // Not in backend create payload
  final String id;
  @JsonKey(name: 'exercise_id')
  final String exerciseId;
  @JsonKey(name: 'exercise_name')
  final String exerciseName;
  @JsonKey(name: 'exercise_equipments')
  final List<String>? exerciseEquipments;
  @JsonKey(name: 'exercise_gif_url')
  final String? exerciseGifUrl;
  final List<CompletedWorkoutSet> sets; // This will call toJson on each set
  @JsonKey(
    includeToJson: false,
    includeFromJson: false,
  ) // Not in backend create payload
  final DateTime createdAt;

  CompletedWorkoutExercise({
    String? id,
    required this.exerciseId,
    required this.exerciseName,
    this.exerciseEquipments,
    this.exerciseGifUrl,
    required this.sets,
    DateTime? createdAt,
  }) : id = id ?? const Uuid().v4(),
       createdAt = createdAt ?? DateTime.now();

  factory CompletedWorkoutExercise.fromJson(Map<String, dynamic> json) =>
      _$CompletedWorkoutExerciseFromJson(json);
  Map<String, dynamic> toJson() => _$CompletedWorkoutExerciseToJson(this);

  // For SQLite
  factory CompletedWorkoutExercise.fromMap(Map<String, dynamic> map) {
    return CompletedWorkoutExercise(
      id: map['id'] as String,
      exerciseId: map['exercise_id'] as String, // Corrected from exerciseId
      exerciseName:
          map['exercise_name'] as String, // Corrected from exerciseName
      exerciseEquipments:
          map['exercise_equipments'] !=
                  null // Corrected from exerciseEquipments
              ? List<String>.from(
                jsonDecode(map['exercise_equipments'] as String),
              )
              : null,
      exerciseGifUrl:
          map['exercise_gif_url'] as String?, // Corrected from exerciseGifUrl
      sets: [], // Sets are loaded separately by DatabaseHelper
      createdAt: DateTime.parse(
        map['created_at'] as String,
      ), // Corrected from createdAt
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'exercise_id': exerciseId, // Corrected to exercise_id
      'exercise_name': exerciseName, // Corrected to exercise_name
      'exercise_equipments':
          exerciseEquipments != null
              ? jsonEncode(exerciseEquipments)
              : null, // Corrected to exercise_equipments
      'exercise_gif_url': exerciseGifUrl, // Corrected to exercise_gif_url
      // 'sets' are not included here as they are stored in a separate table
      'created_at': createdAt.toIso8601String(), // Corrected to created_at
    };
  }

  CompletedWorkoutExercise copyWith({
    String? id,
    String? exerciseId,
    String? exerciseName,
    List<String>? exerciseEquipments,
    String? exerciseGifUrl,
    List<CompletedWorkoutSet>? sets,
    DateTime? createdAt,
  }) {
    return CompletedWorkoutExercise(
      id: id ?? this.id,
      exerciseId: exerciseId ?? this.exerciseId,
      exerciseName: exerciseName ?? this.exerciseName,
      exerciseEquipments: exerciseEquipments ?? this.exerciseEquipments,
      exerciseGifUrl: exerciseGifUrl ?? this.exerciseGifUrl,
      sets: sets ?? this.sets,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}

@JsonSerializable(explicitToJson: true) // Ensure nested toJson is called
class CompletedWorkout {
  @JsonKey(
    includeToJson: false,
    includeFromJson: false,
  ) // Not in backend create payload
  final String id;
  @JsonKey(
    includeToJson: false,
    includeFromJson: false,
  ) // Set by backend based on token
  final String userId;
  @JsonKey(name: 'original_workout_id', includeIfNull: false)
  final String? originalWorkoutId;
  @JsonKey(name: 'workout_name')
  final String workoutName;
  @JsonKey(name: 'workout_icon_url', includeIfNull: false)
  final String? workoutIconUrl;
  @JsonKey(name: 'start_time')
  final DateTime startTime;
  @JsonKey(name: 'end_time')
  final DateTime endTime;
  @JsonKey(name: 'duration_seconds')
  final int durationSeconds;
  @JsonKey(name: 'intensity_score')
  final double intensityScore;
  final List<CompletedWorkoutExercise>
  exercises; // This will call toJson on each exercise
  @JsonKey(
    includeToJson: false,
    includeFromJson: false,
  ) // Not in backend create payload
  final DateTime createdAt;

  @JsonKey(
    includeToJson: false,
    includeFromJson: false,
  ) // Derived, not for JSON
  Duration get duration => Duration(seconds: durationSeconds);

  CompletedWorkout({
    String? id,
    this.userId = '',
    this.originalWorkoutId,
    required this.workoutName,
    this.workoutIconUrl,
    required this.startTime,
    required this.endTime,
    required this.durationSeconds,
    required this.intensityScore,
    required this.exercises,
    DateTime? createdAt,
  }) : id = id ?? const Uuid().v4(),
       createdAt = createdAt ?? DateTime.now();

  factory CompletedWorkout.fromJson(Map<String, dynamic> json) =>
      _$CompletedWorkoutFromJson(json);
  Map<String, dynamic> toJson() => _$CompletedWorkoutToJson(this);

  // For SQLite
  factory CompletedWorkout.fromMap(Map<String, dynamic> map) {
    // accept both snake_case (from sqlite) and camelCase (if any) keys
    String getStr(Map<String, dynamic> m, String snake, String camel) {
      return (m[snake] as String?) ?? (m[camel] as String?) ?? '';
    }

    String? getNullableStr(Map<String, dynamic> m, String snake, String camel) {
      return (m[snake] as String?) ?? (m[camel] as String?);
    }

    int getInt(Map<String, dynamic> m, String snake, String camel) {
      return (m[snake] as int?) ?? (m[camel] as int?) ?? 0;
    }

    double getDouble(Map<String, dynamic> m, String snake, String camel) {
      final val = (m[snake]) ?? (m[camel]);
      if (val == null) return 0.0;
      if (val is double) return val;
      if (val is int) return val.toDouble();
      return double.tryParse(val.toString()) ?? 0.0;
    }

    DateTime parseDate(Map<String, dynamic> m, String snake, String camel) {
      final s = (m[snake] as String?) ?? (m[camel] as String?);
      return s != null ? DateTime.parse(s) : DateTime.now();
    }

    return CompletedWorkout(
      id: getStr(map, 'id', 'id'),
      userId: getStr(map, 'user_id', 'userId'),
      originalWorkoutId: getNullableStr(
        map,
        'original_workout_id',
        'originalWorkoutId',
      ),
      workoutName: getStr(map, 'workout_name', 'workoutName'),
      workoutIconUrl: getNullableStr(map, 'workout_icon_url', 'workoutIconUrl'),
      startTime: parseDate(map, 'start_time', 'startTime'),
      endTime: parseDate(map, 'end_time', 'endTime'),
      durationSeconds: getInt(map, 'duration_seconds', 'durationSeconds'),
      intensityScore: getDouble(map, 'intensity_score', 'intensityScore'),
      exercises: [], // Exercises are loaded separately by DatabaseHelper
      createdAt: parseDate(map, 'created_at', 'createdAt'),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'user_id': userId,
      'original_workout_id': originalWorkoutId,
      'workout_name': workoutName,
      'workout_icon_url': workoutIconUrl,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime.toIso8601String(),
      'duration_seconds': durationSeconds,
      'intensity_score': intensityScore,
      // exercises are stored in a separate table
      'created_at': createdAt.toIso8601String(),
    };
  }

  CompletedWorkout copyWith({
    String? id,
    String? userId,
    String? originalWorkoutId,
    String? workoutName,
    String? workoutIconUrl,
    DateTime? startTime,
    DateTime? endTime,
    int? durationSeconds,
    double? intensityScore,
    List<CompletedWorkoutExercise>? exercises,
    DateTime? createdAt,
  }) {
    return CompletedWorkout(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      originalWorkoutId: originalWorkoutId ?? this.originalWorkoutId,
      workoutName: workoutName ?? this.workoutName,
      workoutIconUrl: workoutIconUrl ?? this.workoutIconUrl,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      intensityScore: intensityScore ?? this.intensityScore,
      exercises: exercises ?? this.exercises,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}
